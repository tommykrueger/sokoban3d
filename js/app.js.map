{"version":3,"sources":["app.js","log.js","utils.js","view.js","character.js","item.js","level.js","lift.js","shader.js","threescene.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":["import Log from './app/log';\r\nimport ThreeScene from './components/threescene.js';\r\n\r\nexport default class App {\r\n  \r\n  constructor () {\r\n\r\n    this.resolutions = {\r\n\r\n      low: {\r\n\r\n        sphereSegments: 32\r\n\r\n      },\r\n\r\n      high: {\r\n\r\n        sphereSegments: 128\r\n\r\n      }\r\n\r\n    }\r\n\r\n\r\n    this.defaultOptions = {\r\n\r\n      // the level of detail\r\n      resolution: this.resolutions['low'],\r\n\r\n      // rendering mode\r\n      view: '3d',\r\n\r\n      // render statistics as well\r\n      renderStats: true,\r\n\r\n    };\r\n\r\n\r\n    this.setDevelopmentMode();\r\n    this.init();\r\n\r\n  }\r\n\r\n\r\n  init () {\r\n\r\n    this.THREESCENE = new ThreeScene(this.defaultOptions);\r\n\r\n  }\r\n\r\n\r\n  setResolution (resolution = 'low') {\r\n\r\n    this.defaultOptions.resolution = this.resolutions[resolution];\r\n\r\n  }\r\n\r\n\r\n  setDevelopmentMode () {\r\n\r\n    window.isDevelopmentMode = true;\r\n\r\n  }\r\n\r\n};\r\n\r\nnew App();","export var __useDefault = true;\r\n\r\nexport default class Log {\r\n\r\n  init () {}\r\n\r\n  info (message) {\r\n  \tthis.print(message, 'info');\r\n  }\r\n\r\n  error (message) {\r\n\t\tthis.print(message, 'error');\r\n  }\r\n\r\n  print (message, type = 'info') {\r\n  \tif (typeof(console) === 'object' && window.console.log) {\r\n  \t\tconsole.log(message);\r\n  \t}\r\n  }\r\n}","import THREE from 'three.js';\r\n\r\nexport var __useDefault = true;\r\n\r\n\r\n/**\r\n * Utility class to be used for global functions\r\n */\r\n\r\nexport default class Utils {\r\n\r\n\tconstructor() {\r\n\r\n\t\t// the distance of one astronomical unit in kilometers\r\n\t\tthis.AU = 149597870.700;\r\n\r\n\t\t// the distance for one light year in km\r\n\t\tthis.LY = 9460730472580.800;\r\n\r\n\t\t// the distance of one parsec in light years\r\n\t\tthis.PC = 3.26156;\r\n\r\n\t\t// define how large 1px is in comparison to the the real world size\r\n\t\t// every distance will be divided by this value\r\n\t\tthis.distancePixelRatio = Math.round(149597870.700 / 10.0);\r\n\r\n\r\n\t\t// set the default rotation time in days for stars\r\n\t\tthis.defaultStarRotationPeriod = 25.00;\r\n\r\n\t\tthis.radiusSun = 696342; // km\r\n\r\n\r\n\t\tthis.radiusEarth = 6371;\r\n\r\n\t\t// For stars\r\n\t\tthis.radiusStarPixelRatio = 100000000;\r\n\r\n\t\t// For planets, moons, etc\r\n\t\tthis.radiusPixelRatio = 50000;\r\n\r\n\r\n\t\tthis.planetDefaultColor = [0, 0, 200];\r\n\r\n\r\n\t\tthis.orbitTransparency = 0.5;\r\n\r\n\t\tthis.orbitColors = [\r\n\t\t\t0xD59C6F,\r\n\t\t\t0x88bf8b,\r\n\t\t\t0x4682b4,\r\n\t\t\t0xd2691e,\r\n\t\t\t0xf0e68c,\r\n\t\t\t0xffa500,\r\n\t\t\t0xE89296,\r\n\t\t\t0x92DEE8,\r\n\t\t\t0x55732D,\r\n\t\t\t0x0FF7E8,\r\n\r\n\t\t\t0xE3B1E0,\r\n\t\t\t0xCA8E40,\r\n\t\t\t0x983315,\r\n\t\t\t0xA06E00,\r\n\t\t\t0xFFB100,\r\n\t\t\t0xFF6202,\r\n\t\t\t0x00579E,\r\n\t\t\t0x9E600A,\r\n\t\t\t0xFFA301,\r\n\t\t\t0x913E20\r\n\t\t];\r\n\r\n\r\n\r\n\t\tthis.spectralColors = {\r\n\t\t\t'o': 0x9BB0FF, // blue\r\n\t\t\t'b': 0xBBCCFF, // blue white\r\n\t\t\t'a': 0xFBF8FF, // white\r\n\t\t\t'f': 0xFFFFF0, // yellow white\r\n\t\t\t'g': 0xFFFF00, // yellow\r\n\t\t\t'k': 0xFF9833, // orange\r\n\t\t\t'm': 0xBB2020, // red\r\n\t\t\t'l': 0xA52A2A, // red brown\r\n\t\t\t't': 0x964B00, // brown\r\n\t\t\t'y': 0x663300  // dark brown\r\n\t\t};\r\n\r\n\r\n\t}\r\n\r\n\tgetDistance( distance, distanceType = 'ly' ) {\r\n\r\n\t\tif (distanceType.toLowerCase() == 'ly') {\r\n\t\t\treturn (distance * this.LY / this.distancePixelRatio);\r\n\t\t}\t\r\n\r\n\t\tif (distanceType.toLowerCase() == 'au') {\r\n\t\t\treturn (distance * this.AU / this.distancePixelRatio);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * project from 3d to 2d space\r\n\t */ \r\n\ttoScreenPosition(obj, camera) {\r\n\r\n    var vector = new THREE.Vector3();\r\n\r\n    var widthHalf = 0.5 * window.innerWidth;\r\n    var heightHalf = 0.5 * window.innerHeight;\r\n\r\n    obj.updateMatrixWorld();\r\n    vector.setFromMatrixPosition(obj.matrixWorld);\r\n    vector.project(camera);\r\n\r\n    vector.x = ( vector.x * widthHalf ) + widthHalf;\r\n    vector.y = - ( vector.y * heightHalf ) + heightHalf;\r\n\r\n    return { \r\n      x: vector.x,\r\n      y: vector.y\r\n    };\r\n\r\n\t}\r\n\r\n\r\n\tproject2D (mesh, app) {\r\n\r\n\t\tapp.scene.updateMatrixWorld(true);\r\n\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar pos = position.setFromMatrixPosition( mesh.matrixWorld );\r\n\t\t\r\n\t\tapp.camera.updateMatrixWorld(true);\r\n\r\n\t\t// var vector = app.projector.projectVector(pos.clone(), app.camera);\r\n\t\tvar vector = pos.unproject(app.camera);\r\n\r\n\t\tvar pLocal = new THREE.Vector3(0, 0, -1);\r\n\t\tvar pWorld = pLocal.applyMatrix4( app.camera.matrixWorld );\r\n\t\tvar dir = pWorld.sub( app.camera.position ).normalize();\r\n\r\n\t\tvar scalar = (pos.x - app.camera.position.x) / dir.x;\r\n\t\t// window.utils.debug( scalar );\r\n\t\tif (mesh.name == 'Earth') {\r\n  \t\t// window.utils.debug('Earth pos', scalar);\r\n  \t}\r\n\r\n\t  if (scalar < 0) {\r\n\t  \tconsole.log(mesh.name);\r\n\t  \t// window.utils.debug('object behind camera');\r\n\t  \t// return false; // this means the point was behind the camera, so discard\r\n\t  }\r\n\r\n\t\tvector.x = (vector.x + 1)/2 * window.innerWidth;\r\n\t\tvector.y = -(vector.y - 1)/2 * window.innerHeight;\r\n\r\n\t\treturn vector;\r\n\t}\r\n\r\n\r\n\r\n\t// taken from: http://zachberry.com/blog/tracking-3d-objects-in-2d-with-three-js/\r\n\tgetPosition2D ( object, app ) {\r\n\r\n\t\tapp.scene.updateMatrixWorld(true);\r\n\r\n\t\tvar p, v, percX, percY, left, top;\r\n\r\n\t\t// this will give us position relative to the world\r\n\t\tp = object.position.clone();\r\n\r\n\t\tapp.camera.updateMatrixWorld(true);\r\n\r\n\t\t// unproject will translate position to 2d\r\n\t\tv = p.unproject(app.camera);\r\n\r\n\t\t// Pick a point in front of the camera in camera space:\r\n\t\tvar pLocal = new THREE.Vector3(0, 0, -1);\r\n\r\n\t\t// Now transform that point into world space:\r\n\t\tvar pWorld = pLocal.applyMatrix4( app.camera.matrixWorld );\r\n\t\t\r\n\t\t// You can now construct the desired direction vector:\r\n\t\tvar dir = pWorld.sub( app.camera.position ).normalize();\r\n\r\n\t\tvar scalar = (p.x - app.camera.position.x) / dir.x;\r\n\t\t//window.utils.debug( scalar );\r\n\r\n\t  if (scalar < 0) {\r\n\t  \t// window.utils.debug('object behind camera');\r\n\t  \t// return false; //this means the point was behind the camera, so discard\r\n\t  }\r\n\t\t//window.utils.debug( v );\r\n\r\n\t\t// translate our vector so that percX=0 represents\r\n\t\t// the left edge, percX=1 is the right edge,\r\n\t\t// percY=0 is the top edge, and percY=1 is the bottom edge.\r\n\t\tv.x = (v.x + 1)/2 * window.innerWidth;\r\n\t\tv.y = -(v.y - 1)/2 * window.innerHeight;\r\n\r\n\t\treturn v;\r\n\r\n\t}\r\n\r\n\r\n\ttoRad() {\r\n\r\n\t\treturn Math.PI / 180;\r\n\r\n\t}\r\n\r\n\r\n\t// derived from: https://github.com/mrdoob/three.js/blob/master/examples/js/Detector.js\r\n  isWebGLSupported() {\r\n\r\n    try {\r\n      \r\n      let canvas = document.createElement(\"canvas\");\r\n      return !! window.WebGLRenderingContext && (canvas.getContext(\"webgl\") || canvas.getContext(\"experimental-webgl\"));\r\n\r\n    } catch(e) { return false; } \r\n\r\n  }\r\n\r\n  // taken from: http://stackoverflow.com/questions/3177855/how-to-format-numbers-similar-to-stack-overflow-reputation-format\r\n\tnumberFormat(number) {\r\n\t\tvar repString = number.toString();\r\n\r\n\t  if ( number < 1000 ) {\r\n\t\t\trepString = number;\r\n\t  } else if ( number < 1000000 ) {\r\n\t\t\trepString = (Math.round((number / 1000) * 10) / 10) + ' K'\r\n\t  } else if ( number < 1000000000 ) {\r\n\t\t\trepString = (Math.round((number / 1000000) * 10) / 10) + ' Mio'\r\n\t  } else if ( number < 1000000000000000000 ) {\r\n\t\t\trepString = (Math.round((number / 1000000000) * 10) / 10) + ' Bio'\r\n\t  }\r\n\r\n\t  return repString;\r\n\t}\r\n\r\n\r\n\r\n\tgetDimensionToTen( min, max ) {\r\n\r\n\t\tvar size = Math.ceil( max * 100000 ) / 100000;\r\n\r\n\t\tif( max < 0.001 )\r\n\t\t\tsize = Math.ceil( max * 10000 ) / 10000;\r\n\t\telse if( max < 0.01 )\r\n\t\t\tsize = Math.ceil( max * 1000 ) / 1000;\r\n\t\telse if( max < 0.1 )\r\n\t\t\tsize = Math.ceil( max * 100 ) / 100;\r\n\t\telse if( max < 1 )\r\n\t\t\tsize = Math.ceil( max * 10 ) / 10;\r\n\r\n\t\telse {\r\n\t\t\tsize = Math.ceil( max );\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tsize: size,\r\n\t\t\tmax: max,\r\n\t\t\tmin: min,\r\n\t\t\tminPercent: Math.round(min * 100 / size) / 100,\r\n\t\t\tmaxPercent: Math.round(max * 100 / size) / 100\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n  debug(txt) {\r\n\r\n  \tif (window.isDevelopmentMode)\r\n  \t\tconsole.log(txt);\r\n\r\n  }\r\n\r\n\r\n  // taken from: http://jsfiddle.net/Brfp3/3/\r\n\ttextCircle (ctx, text, x, y, radius, space, top){\r\n\t   space = space || 0;\r\n\t   var numRadsPerLetter = (Math.PI - space * 2) / text.length;\r\n\t   ctx.save();\r\n\t   ctx.translate(x,y);\r\n\t   var k = (top) ? 1 : -1; \r\n\t   ctx.rotate(-k * ((Math.PI - numRadsPerLetter) / 2 - space));\r\n\t   for(var i=0;i<text.length;i++){\r\n\t      ctx.save();\r\n\t      ctx.rotate(k*i*(numRadsPerLetter));\r\n\t      ctx.textAlign = \"center\";\r\n\t     \tctx.textBaseline = (!top) ? \"top\" : \"bottom\";\r\n\t     \tctx.fillText(text[i],0,-k*(radius));\r\n\t      ctx.restore();\r\n\t   }\r\n\t   ctx.restore();\r\n\t}\r\n\r\n\r\n}","export var __useDefault = true;\r\n\r\nimport Utils from './utils';\r\n\r\nimport Template from '../views/template';\r\n\r\n/**\r\n * View base class\r\n * Used for all DOM - related objects\r\n * \r\n */\r\n\r\nexport default class View {\r\n\r\n\tconstructor ( options = {} ) {\r\n\r\n\t\tthis.options = options;\r\n\t\tthis.app = options.app;\r\n\r\n\t\tthis.utils = new Utils();\r\n\t\t\r\n\t\tthis.name = '';\r\n\t\tthis.$view = ``;\r\n\r\n\t}\r\n\r\n\tsetData() {\r\n\r\n\t}\r\n\r\n\trender() {\r\n\r\n\t\tthis.$el = this.$view;\r\n\t\treturn this.$el;\r\n\r\n\t}\r\n\r\n\tgetHtml() {\r\n\r\n\t\treturn this.$el.html();\r\n\r\n\t}\r\n\r\n\tappendTo( $element ) {\r\n\r\n\r\n\r\n\t}\r\n\r\n}","import THREE from 'three.js';\r\nimport _ from 'underscore';\r\nimport Utils from '../app/utils';\r\n\r\nexport default class Character {\r\n\r\n\r\n\tconstructor (options = {}) {\r\n\r\n\t\tthis.options = options;\r\n\t\tthis.app = this.options.app;\r\n    this.level = this.options.level;\r\n    this.position = this.options.position;\r\n\r\n    this.delta = 1;\r\n    this.currentPosition = { x: 0, y: 0 };\r\n\r\n\t\tthis.utils = new Utils();\r\n\r\n\t}\r\n \r\n\r\n  render () {\r\n\r\n  \tthis.material = new THREE.MeshLambertMaterial({\r\n  \t\tcolor: 0xff0000, \r\n  \t\ttransparent: false,\r\n  \t\topacity: 1,\r\n  \t\tside: THREE.DoubleSide,\r\n  \t\tblending: THREE.AdditiveBlending \r\n  \t});\r\n\r\n    this.mesh = new THREE.Mesh(\r\n      new THREE.SphereGeometry(.5, 32, 32),\r\n      this.material\r\n    );\r\n\r\n    this.mesh.castShadow = true;\r\n\r\n    this.setPosition();\r\n    this.initControls();\r\n\r\n  }\r\n\r\n\r\n  animate (clock) {\r\n\r\n    let t = Math.sin(clock.getElapsedTime() * 3);\r\n    let scale = Math.max(.86, t);\r\n\r\n    this.mesh.scale.x = scale;\r\n    this.mesh.scale.y = scale;\r\n    this.mesh.scale.z = scale;\r\n\r\n  }\r\n\r\n\r\n  setPosition (position = false) {\r\n\r\n    if (position) this.position = position;\r\n    this.mesh.position.set(this.position.x, .8/2, this.position.z);\r\n\r\n  }\r\n\r\n\r\n\r\n  initControls () {\r\n\r\n    window.addEventListener('keydown', (e) => this.keyDown(e), false);\r\n\r\n  }\r\n\r\n\r\n  getMesh() { \r\n    return this.mesh;\r\n  }\r\n\r\n\r\n  keyDown(event) {\r\n\r\n    event = event || window.event;\r\n\r\n    var keycode = event.keyCode;\r\n\r\n    switch(keycode){\r\n        case 37: // left arrow\r\n        this.move('left');\r\n      break;\r\n        case 38: // up arrow\r\n        this.move('up');\r\n      break;\r\n        case 39: // right arrow\r\n        this.move('right');\r\n      break;\r\n        case 40: // down arrow\r\n        this.move('down');\r\n      break;\r\n    }\r\n\r\n  }\r\n\r\n\r\n  move (direction = 'down') {\r\n\r\n    if (this.canMove(direction)) {\r\n\r\n      let oldPos = Object.assign({}, this.currentPosition);\r\n\r\n      if (direction == 'left') {\r\n        this.currentPosition.x -= 1;\r\n        this.mesh.position.x -= this.delta; \r\n      }\r\n\r\n      if (direction == 'right') {\r\n        this.currentPosition.x += 1;\r\n        this.mesh.position.x += this.delta; \r\n      }\r\n\r\n      if (direction == 'up') {\r\n        this.currentPosition.y -= 1;\r\n        this.mesh.position.z -= this.delta; \r\n      }\r\n\r\n      if (direction == 'down') {\r\n        this.currentPosition.y += 1;\r\n        this.mesh.position.z += this.delta; \r\n      }\r\n\r\n      if (this.level.isObjectInFront('gift', this.currentPosition)) {\r\n\r\n        console.log('we fond a gift ', this.level.isObjectInFront('gift', this.currentPosition));\r\n\r\n      }\r\n\r\n      this.app.$interface.addMove();\r\n      this.app.$interface.update();\r\n      this.app.level.lift.check();\r\n\r\n      // this.hasFoundKey();\r\n\r\n      this.level.checkSolved();\r\n\r\n    }\r\n\r\n  }\r\n\r\n\r\n  // check if there is an obstacle before moving\r\n  canMove (direction) {\r\n\r\n    let targetPosition = Object.assign({}, this.currentPosition); \r\n\r\n    // let targetFrontPosition = new THREE.Vector3(targetPosition.x, targetPosition.y, targetPosition.z); \r\n    let targetFrontPosition = Object.assign({}, this.currentPosition);\r\n    let pFrontOld = Object.assign({}, targetFrontPosition);\r\n    let pOld = Object.assign({}, targetPosition);\r\n\r\n\r\n    if (direction == 'left') {\r\n      targetPosition.x -= this.delta;\r\n      targetFrontPosition.x -= this.delta * 2;\r\n    }\r\n\r\n    if (direction == 'right') {\r\n      targetPosition.x += this.delta; \r\n      targetFrontPosition.x += this.delta * 2;\r\n    }\r\n\r\n    if (direction == 'up') {\r\n      targetPosition.y -= this.delta; \r\n      targetFrontPosition.y -= this.delta * 2;\r\n    }\r\n\r\n    if (direction == 'down') {\r\n      targetPosition.y += this.delta; \r\n      targetFrontPosition.y += this.delta * 2;\r\n    }\r\n\r\n\r\n    if (this.level.isObjectInFront('wall', targetPosition)) {\r\n\r\n      console.log('cannot move becase thee is a wall infont');\r\n      return false;\r\n\r\n    }\r\n\r\n\r\n    let object = this.level.isObjectInFront('box', targetPosition);\r\n\r\n    if (object) {\r\n\r\n      console.log('in font is a box, can we move it?', object);\r\n\r\n      // check if in front of the box is a free place\r\n      if (!this.level.isObjectInFront('wall', targetFrontPosition) && !this.level.isObjectInFront('box', targetFrontPosition)) {\r\n\r\n        let pNew = {\r\n          x: targetFrontPosition.x, \r\n          y: 0, \r\n          z: targetFrontPosition.y \r\n        }\r\n\r\n        this.level.moveObject(object.item, pNew);\r\n        this.level.updateBoxes(object, pNew);\r\n\r\n        this.app.$interface.addBoxMove();\r\n\r\n      } else {\r\n\r\n        console.log('cannot move becase thee is a box o wall infont of anothe box');\r\n        return false;\r\n\r\n      }\r\n\r\n    }\r\n\r\n    return true;\r\n\r\n  }\r\n\r\n\r\n  moveToFloor (oldFloor, newfloor) {\r\n\r\n    if (this.app.level.floors[oldFloor])\r\n      this.app.level.floors[oldFloor].remove(this.mesh);\r\n\r\n    if (this.app.level.floors[newfloor])\r\n      this.app.level.floors[newfloor].add(this.mesh);\r\n\r\n  }\r\n\r\n\r\n  /**\r\n   * the playe eaches a field with a key\r\n   */\r\n  hasFoundKey () {\r\n\r\n    this.level.removeGate();\r\n\r\n  }\r\n\r\n\r\n}","import THREE from 'three.js';\r\nimport _ from 'underscore';\r\nimport Utils from '../app/utils';\r\n\r\n\r\nexport default class Item {\r\n\r\n\r\n\tconstructor (options = {}) {\r\n\r\n\t\tthis.options = options;\r\n\t\tthis.app = this.options.app;\r\n\t\tthis.level = this.options.level;\r\n\r\n\t\tthis.utils = new Utils();\r\n\r\n    // the three.js object of the item\r\n    this.mesh;\r\n\r\n    // means the player can interact with this item\r\n    this.isInteractable = false;\r\n\r\n\t}\r\n \r\n  // to be implemented by extending class object\r\n  render () {}\r\n\r\n\r\n\r\n  /**\r\n   * Animate all the child elements of this level\r\n   */\r\n  animate (clock) {\r\n\r\n    // define custom item based animation function here\r\n\r\n  }\r\n\r\n\r\n  move (targetPosition) {\r\n\r\n    this.mesh.position.x = targetPosition.x;\r\n    // this.mesh.position.y = targetPosition.y;\r\n    this.mesh.position.z = targetPosition.z;\r\n\r\n  }\r\n\r\n\r\n  setFloorPosition (position) {\r\n\r\n    this.mesh.position.y = position;\r\n\r\n  }\r\n\r\n\r\n  getMesh() {\r\n\r\n    return this.mesh;\r\n\r\n  }\r\n\r\n\r\n}","import THREE from 'three.js';\r\nimport _ from 'underscore';\r\nimport Utils from '../app/utils';\r\n\r\n\r\n// standalone classes\r\nimport Lift from './lift';\r\n\r\n\r\n// import items\r\nimport WallItem from './items/wall';\r\nimport TargetItem from './items/target';\r\nimport FloorItem from './items/floor';\r\nimport BoxItem from './items/box';\r\nimport LiftItem from './items/lift';\r\nimport KeyItem from './items/key';\r\nimport GiftItem from './items/gift';\r\n\r\nimport Character from './character';\r\n\r\n\r\n// helper classes\r\nimport Text from '../helpers/text';\r\n\r\n\r\nexport default class Level {\r\n\r\n\r\n\tconstructor (options = {}) {\r\n\r\n\t\tthis.options = options;\r\n\t\tthis.app = this.options.app;\r\n\t\tthis.level = this.options.level;\r\n\r\n\t\tthis.utils = new Utils();\r\n\r\n    this.boxes = [];\r\n    this.floors = [];\r\n\t\tthis.meshes = [];\r\n\r\n    this.targetPoints = 0;\r\n\r\n    this.group = new THREE.Group();\r\n    this.floor = new THREE.Group();\r\n\r\n    this.group.add(this.floor);\r\n    this.app.scene.add(this.group);\r\n\r\n    this.width = options.level.width;\r\n    this.height = options.level.height;\r\n\r\n    this.currentFloor = options.level.currentFloor || 0;\r\n\r\n    // the height of each floor in pixels\r\n    this.floorHeight = 3;\r\n\r\n    // holds all the three.js items rendered in this level\r\n    this.items = [];\r\n\r\n    this.world = { floors: [] };\r\n\r\n    this.walls = { floors: [] };\r\n    this.boxes = { floors: [] };\r\n    this.lifts = { floors: [] };\r\n    this.targets = { floors: [] };\r\n    this.keys = { floors: [] };\r\n    this.gifts = { floors: [] };\r\n\r\n    this.level.floors.forEach((floor, index) => {\r\n      this.world.floors.push({ name: floor.name, map: [] });\r\n      this.walls.floors[index] = [];\r\n      this.boxes.floors[index] = [];\r\n      this.lifts.floors[index] = [];\r\n      this.targets.floors[index] = [];\r\n      this.keys.floors[index] = [];\r\n      this.gifts.floors[index] = [];\r\n    });\r\n\r\n\r\n    this.symbols = {\r\n      '@': 'character',\r\n      '.': 'target',\r\n      '#': 'wall', \r\n      '-': 'floor', \r\n      'b': 'box',\r\n      'l': 'lift',\r\n      '?': 'gift'\r\n    }\r\n      \r\n\r\n\t\tthis.materials = {\r\n\r\n\t  \tfloor: new THREE.MeshLambertMaterial({\r\n\t  \t\tcolor: 0x666666, \r\n\t  \t\ttransparent: false,\r\n\t  \t\topacity: 1,\r\n\t  \t\tside: THREE.DoubleSide,\r\n\t  \t\tblending: THREE.AdditiveBlending \r\n\t  \t})\r\n\r\n\t\t};\r\n\r\n    this.prepareLevelStructure();\r\n    this.setLevelPosition();\r\n\r\n\t}\r\n\r\n\r\n  prepareLevelStructure() {\r\n\r\n    if (this.level.floors) {\r\n      this.level.floors.forEach((floor, index) => {\r\n        let group = new THREE.Object3D();\r\n        this.floors.push(group);\r\n        this.group.add(group);\r\n      });\r\n    }\r\n\r\n  }\r\n\r\n\r\n\r\n  setLevelPosition() {\r\n    this.group.position.x -= this.width / 2;\r\n    this.group.position.z -= this.height / 2;\r\n\r\n    this.app.camera.lookAt(this.group.position);\r\n  }\r\n\r\n\r\n\r\n  focusFloor () {\r\n\r\n    this.floors.forEach((floor, index) => {\r\n\r\n      if (index != this.currentFloor) {\r\n\r\n        floor.traverse((child) => {\r\n          if (child.children.length) {\r\n            child.children.forEach((mesh) => {\r\n              mesh.material.transparent = true;\r\n              mesh.material.opacity = .1;\r\n            });\r\n          }\r\n        });\r\n\r\n      } else {\r\n\r\n        floor.traverse((child) => {\r\n          if (child.children.length) {\r\n            child.children.forEach((mesh) => {\r\n\r\n              if (mesh instanceof THREE.Mesh)\r\n                mesh.material.transparent = false;\r\n            });\r\n          }\r\n        });\r\n\r\n      }\r\n      \r\n    });\r\n\r\n    // move the camera\r\n    this.app.updateCamera(this.currentFloor * this.floorHeight);\r\n\r\n  }\r\n \r\n\r\n\r\n  render () {\r\n\r\n  \tif (this.level.floors) {\r\n\r\n      this.level.floors.forEach(( floor, index ) => {\r\n\r\n        this.floors[index].position.y = index * this.floorHeight;\r\n\r\n    \t\tfloor.map.forEach(( row, i ) => {\r\n\r\n          this.world.floors[index].map.push([]);\r\n    \t\t\t\r\n    \t\t\trow.forEach(( col, j ) => {\r\n\r\n            let position = new THREE.Vector3(j, 0, i);\r\n            let item;\r\n            let options = {\r\n              app: this.app, \r\n              level: this, \r\n              position: position\r\n            };\r\n\r\n    \t\t\t\tswitch(col) {\r\n\r\n              case '@':\r\n\r\n                this.character = new Character(options);\r\n                this.character.render();\r\n                this.character.currentPosition.x = j;\r\n                this.character.currentPosition.y = i;\r\n\r\n                // this.character = item;\r\n                this.floors[index].add(this.character.getMesh());\r\n                this.items.push(this.character);\r\n\r\n                break;\r\n\r\n              case '-':\r\n                \r\n                break;\r\n\r\n    \t\t\t\t\tcase '#':\r\n              case '1':\r\n              case '2':\r\n              case '3':\r\n              case '4':\r\n              case '5':\r\n              case '6':\r\n              case '7':\r\n              case '8':\r\n              case '9':\r\n              case '10':\r\n\r\n                options.height = col;\r\n                item = new WallItem(options);\r\n\r\n                this.walls.floors[index].push({\r\n                  id: 'floor-' + index +'-'+ i +'-'+ j,\r\n                  item: item,\r\n                  position: position\r\n                });\r\n\r\n    \t\t\t\t\t\tbreak;\r\n\r\n  \t\t\t\t\t\tcase '.':\r\n                item = new TargetItem(options);\r\n\r\n                this.targets.floors[index].push({\r\n                  id: 'floor-' + index +'-'+ i +'-'+ j,\r\n                  item: item,\r\n                  position: position\r\n                });\r\n\r\n                this.targetPoints++;\r\n    \t\t\t\t\t\tbreak;\r\n\r\n  \t\t\t\t\t\tcase 'b':\r\n                item = new BoxItem(options);\r\n\r\n                this.boxes.floors[index].push({\r\n                  id: 'floor-' + index +'-'+ i +'-'+ j,\r\n                  item: item,\r\n                  position: position\r\n                });\r\n\r\n    \t\t\t\t\t\tbreak;\r\n\r\n              case 'l':\r\n                item = new LiftItem(options);\r\n\r\n                this.lifts.floors[index].push({\r\n                  id: 'floor-' + index +'-'+ i +'-'+ j,\r\n                  item: item,\r\n                  position: position\r\n                });\r\n\r\n                break;\r\n\r\n              case 'k':\r\n                item = new KeyItem(options);\r\n\r\n                /*\r\n                this.lifts.floors[index].push({\r\n                  id: 'floor-' + index +'-'+ i +'-'+ j,\r\n                  item: item,\r\n                  position: position\r\n                });\r\n                */\r\n\r\n                break;\r\n\r\n              case '?':\r\n\r\n                options = Object.assign({\r\n                  type: 'text',\r\n                  text: '?'\r\n                }, options);\r\n\r\n                item = new GiftItem(options);\r\n\r\n                this.gifts.floors[index].push({\r\n                  id: 'floor-' + index +'-'+ i +'-'+ j,\r\n                  item: item,\r\n                  position: position\r\n                });\r\n\r\n                this.items.push(item);\r\n\r\n                break;\r\n    \t\t\t\t}\r\n\r\n\r\n            if (item) {\r\n\r\n              item.render();\r\n\r\n              this.world.floors[index].map[i].push({\r\n                type: col,\r\n                item: item\r\n              });\r\n\r\n              this.meshes.push(item.getMesh());\r\n              this.floors[index].add(item.getMesh());\r\n            }\r\n\r\n\r\n\r\n            let floor = new FloorItem(options);\r\n                floor.render();\r\n\r\n            this.floors[index].add(floor.getMesh());\r\n\r\n\r\n  \t\t\t\t});\r\n\r\n  \t\t\t});  \r\n\r\n      });       \r\n\r\n  \t}\r\n\r\n    console.log(this.world);\r\n    this.afterRender();\r\n\r\n  }\r\n\r\n\r\n  afterRender () {\r\n\r\n    this.lift = new Lift({ app: this.app, lifts: this.lifts });\r\n    this.focusFloor();\r\n\r\n  }\r\n\r\n\r\n  /**\r\n   * Animate all the child elements of this level\r\n   */\r\n  animate (clock) {\r\n\r\n    this.items.forEach( (item) => {\r\n      if ( typeof(item.animate) === 'function') {\r\n        item.animate(clock);\r\n      }\r\n    });\r\n\r\n  }\r\n\r\n\r\n  /**\r\n   * Once the corbyn moves to another floor - eg with a lift\r\n   * he enters a new floor\r\n   */\r\n  setFloor (index) {\r\n\r\n    this.currentFloor = index;\r\n\r\n  }\r\n\r\n\r\n\r\n  isObjectInFront (objectType, position) {\r\n\r\n    let object = false;\r\n\r\n    if (objectType === 'wall') {\r\n      this.walls.floors[this.currentFloor].forEach((wall) => {\r\n        if (wall.position.x == position.x && wall.position.z == position.y) {\r\n          object = wall;\r\n        }\r\n      });\r\n    } \r\n\r\n\r\n    if (objectType === 'box') {\r\n      this.boxes.floors[this.currentFloor].forEach((box) => {\r\n        if (box.position.x == position.x && box.position.z == position.y) {\r\n          object = box;\r\n        }\r\n      });\r\n    } \r\n\r\n    if (objectType === 'gift') {\r\n      this.gifts.floors[this.currentFloor].forEach((gift) => {\r\n        if (gift.position.x == position.x && gift.position.z == position.y) {\r\n          object = gift;\r\n        }\r\n      });\r\n    }\r\n\r\n    return object;\r\n\r\n  }\r\n\r\n\r\n  isObjectAtPosition (objectType, position) {\r\n\r\n    let object = false;\r\n\r\n    if (objectType === 'lift') {\r\n      this.lifts.floors[this.currentFloor].forEach((lift) => {\r\n        if (lift.position.x == position.x && lift.position.z == position.y) {\r\n          object = lift;\r\n        }\r\n      });\r\n    } \r\n\r\n    return object;\r\n\r\n  }\r\n\r\n\r\n\r\n  updateFloorItems (items, oldFloor, newFloor) {\r\n\r\n    console.log('updating items');\r\n\r\n    items.forEach((item) => {\r\n\r\n      console.log(item);\r\n\r\n      this.boxes.floors[oldFloor].forEach((box, index) => {\r\n        if (box.id === item.id) {\r\n          this.boxes.floors[oldFloor].splice(index, 1);  \r\n          this.boxes.floors[newFloor].push(box);  \r\n\r\n          this.floors[oldFloor].remove(item.item.mesh);\r\n          this.floors[newFloor].add(item.item.mesh);\r\n        }\r\n      });\r\n\r\n    });\r\n\r\n\r\n  }\r\n\r\n\r\n  updateBoxes (object, position) {\r\n\r\n    this.boxes.floors[this.currentFloor].forEach((box) => {\r\n      if (box.id === object.id) {\r\n        box.position.x = position.x;\r\n        box.position.z = position.z;\r\n      }\r\n    });\r\n\r\n  }\r\n\r\n\r\n\r\n  moveObject (item, targetPosition) {\r\n\r\n    item.mesh.position.x = targetPosition.x;\r\n    // item.mesh.position.y = targetPosition.y;\r\n    item.mesh.position.z = targetPosition.z;\r\n\r\n  }\r\n\r\n\r\n\r\n  checkSolved () {\r\n\r\n    let solved = false;\r\n    let targetsWithBoxes = 0;\r\n    let boxes = 0;\r\n\r\n\r\n    this.boxes.floors.forEach((floor, boxIndex) => {\r\n      floor.forEach((box) => {\r\n\r\n        boxes++;\r\n\r\n        this.targets.floors.forEach((targets, targetIndex) => {\r\n          targets.forEach((target) => {\r\n            if (boxIndex == targetIndex && box.position.x == target.position.x && box.position.z == target.position.z) {\r\n              targetsWithBoxes++;\r\n            }\r\n          });\r\n        });\r\n\r\n      });\r\n    });\r\n\r\n    // console.log('solved?', targetsWithBoxes, this.targetPoints);\r\n \r\n    if (boxes === targetsWithBoxes) {\r\n      solved = true;\r\n      console.log('level solved ', solved, boxes);\r\n\r\n      //this.text = new Text({app: this.app, text: '?'});\r\n      //this.text.render();\r\n    }\r\n\r\n  }\r\n\r\n\r\n}","import THREE from 'three.js';\r\n\r\nexport default class Lift {\r\n\r\n\r\n\tconstructor (options = {}) {\r\n\r\n    this.app = options.app;\r\n    this.lifts = options.lifts;\r\n\r\n    this.meshes = [];\r\n\r\n\t}\r\n \r\n\r\n  render () {\r\n\r\n    this.liftItems();\r\n\r\n  }\r\n\r\n\r\n  /**\r\n   * find the items that ae on the lift and waiting fo moving\r\n   */\r\n  getItemsInLift () {\r\n\r\n    let items = [];\r\n\r\n    this.app.level.boxes.floors[this.app.level.currentFloor].forEach((box) => {\r\n      this.app.level.lifts.floors[this.app.level.currentFloor].forEach((lift) => {\r\n        if (box.position.x == lift.position.x && box.position.z == lift.position.z) {\r\n          items.push(box);\r\n        }\r\n      });\r\n    });\r\n\r\n    return items;\r\n\r\n  }\r\n\r\n\r\n  /**\r\n   * Move the lift one level up\r\n   */\r\n  moveUp () {\r\n\r\n    let floor = this.app.level.currentFloor;\r\n    let floorHeight = this.app.level.floorHeight;\r\n\r\n    if (floor < this.app.level.floors.length) {\r\n\r\n      let items = this.getItemsInLift();\r\n      console.log(items);\r\n\r\n      this.app.level.currentFloor++;\r\n      this.app.level.updateFloorItems(items, floor, this.app.level.currentFloor);\r\n\r\n      this.lifts.floors[floor].forEach((lift) => {\r\n        console.log('items as lift', lift);\r\n        //lift.item.setFloorPosition(this.app.level.currentFloor * floorHeight);\r\n      }); \r\n\r\n    }\r\n\r\n    this.app.level.character.moveToFloor(floor, this.app.level.currentFloor);\r\n    this.app.level.focusFloor();\r\n\r\n    this.check();\r\n\r\n  }\r\n\r\n  /**\r\n   * Move the lift one level down\r\n   */\r\n  moveDown () {\r\n\r\n    let floor = this.app.level.currentFloor;\r\n    let floorHeight = this.app.level.floorHeight;\r\n\r\n    if (floor < this.app.level.floors.length) {\r\n\r\n      let items = this.getItemsInLift();\r\n      console.log(items);\r\n\r\n      this.app.level.currentFloor--;\r\n      this.app.level.updateFloorItems(items, floor, this.app.level.currentFloor);\r\n\r\n      this.lifts.floors[floor].forEach((lift) => {\r\n        console.log('items as lift', lift);\r\n        //lift.item.setFloorPosition(this.app.level.currentFloor * floorHeight);\r\n      });\r\n\r\n    }\r\n\r\n    this.app.level.character.moveToFloor(floor, this.app.level.currentFloor);\r\n    this.app.level.focusFloor();\r\n\r\n    this.check();\r\n\r\n  }\r\n\r\n\r\n  check () {\r\n\r\n    let object = this.app.level.isObjectAtPosition('lift', this.app.level.character.currentPosition);\r\n\r\n    if (object) {\r\n\r\n      console.log(this.app.level.currentFloor, this.app.level.floors.length);\r\n\r\n      if (this.app.level.currentFloor < this.app.level.floors.length-1) \r\n        this.app.$liftUpButton.activate();\r\n      else \r\n        this.app.$liftUpButton.deactivate();\r\n\r\n      if (this.app.level.currentFloor > 0)\r\n        this.app.$liftDownButton.activate();\r\n      else\r\n        this.app.$liftDownButton.deactivate();\r\n\r\n    } else {\r\n\r\n      this.app.$liftUpButton.deactivate();\r\n      this.app.$liftDownButton.deactivate();\r\n\r\n    }\r\n\r\n  }\r\n\r\n\r\n  animate (clock) {}\r\n\r\n}","import $ from 'jquery';\r\nimport THREE from 'three.js';\r\n\r\nexport var __useDefault = true;\r\n\r\nexport default class Shader {\r\n\r\n\r\n\tconstructor ( options = {} ) {\r\n\r\n\t\tthis.options = options;\r\n\r\n\t\tthis.shader = this.options.shader;\r\n\t\tthis.uniforms = this.options.uniforms || [];\r\n\t\tthis.attributes = this.options.attributes || [];\r\n\r\n\t\tthis.isAnimateable = true;\r\n\t\tthis.material = null;\r\n\r\n\t\tthis.materials = {\r\n\t\t\tvertex: '',\r\n\t\t\tfragment: ''\r\n\t\t}\r\n\r\n\t\tthis.i = 2;\r\n\r\n\t}\r\n\r\n\r\n\tload ( callback = {} ) {\r\n\r\n\t\tthis.call({\r\n\t\t\turl: '../src/js/shaders/vertex-shader-'+ this.shader +'.js',\r\n\t\t\tshaderType: 'vertex',\r\n\t\t\tcallback: callback\r\n\t\t});\r\n\r\n\t\tthis.call({\r\n\t\t\turl: '../src/js/shaders/fragment-shader-'+ this.shader +'.js',\r\n\t\t\tshaderType: 'fragment',\r\n\t\t\tcallback: callback\r\n\t\t});\r\n\r\n\t}\r\n\r\n\r\n\tgetMaterial () {\r\n\t\treturn this.material;\r\n\t}\r\n\r\n\r\n\tsetMaterial () {\r\n\r\n\t\tthis.material = new THREE.ShaderMaterial({  \r\n\t\t  uniforms: this.uniforms,\r\n\t\t  vertexShader: this.materials['vertex'],\r\n\t\t  fragmentShader: this.materials['fragment'],\r\n\r\n\t\t\tblending: THREE.NormalBlending,\r\n\r\n\t\t  transparent: true,\r\n\t\t  depthTest: false,\r\n\t\t  depthWrite: false\r\n\t\t});\r\n\r\n\r\n\t\t// this.uniforms.tNoise.value.wrapS = this.uniforms.tNoise.value.wrapT = THREE.RepeatWrapping;\r\n\r\n\t}\r\n\r\n\r\n\tsetAttributes ( attributes = {} ) {\r\n\t\tthis.attributes = attributes;\r\n\t}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\tcall ( options = {} ) {\r\n\r\n\t\t$.ajax({\r\n\t\t\turl: options.url,\r\n\t\t\tdataType: 'text',\r\n\t\t\tasync: false,\r\n\t\t\tsuccess: (data) => {\r\n\r\n\t\t\t\tthis.materials[options.shaderType] = data;\r\n\t\t\t\tthis.i--;\r\n\r\n\t\t\t\tif (this.i == 0) {\r\n\t\t\t\t\tthis.setMaterial();\r\n\t\t\t\t\toptions.callback(data);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t}\r\n\r\n}","import $ from 'jquery';\r\nimport _ from 'underscore';\r\nimport THREE from 'three.js';\r\nimport Stats from 'stats';\r\n\r\nimport Utils from '../app/utils';\r\nimport Level from '../components/level';\r\n\r\n// views\r\nimport Button from '../views/button';\r\nimport Interface from '../views/interface';\r\n\r\n\r\nexport default class ThreeScene {\r\n  \r\n  constructor (options = {}) {\r\n\r\n  \tthis.utils = new Utils();\r\n  \tthis.options = options;\r\n\r\n  \tthis.meshes = [];\r\n  \tthis.level;\r\n\r\n  \tthis.raycaster = new THREE.Raycaster();\r\n  \tthis.mouse = new THREE.Vector2();\r\n\r\n  \t// to be optimized\r\n  \tthis.time = Date.now();\r\n\t\tthis.simTime = this.time;\r\n\t\tthis.simTimeSecs = null;\r\n\r\n\t\tthis.defaultSpeed = 100;\r\n\r\n\t\tthis.startTime = _.now();\r\n\r\n\t\t// current speed (1 earth day represents 365/100 seconds in app)\t\r\n\t\tthis.currentSpeed = 100;\r\n\t\tthis.speedStep = 100;\r\n\r\n\t\tthis.date = new Date( this.simTime );\r\n\t\tthis.timeElapsedSinceCameraMove = 0;\r\n\t\tthis.timeElapsed = 0;\r\n\r\n\r\n\t\tthis.clock = new THREE.Clock();\r\n\t\tthis.delta = 0;\r\n\r\n  \tthis.prepareScene();\r\n    this.init();\r\n\r\n  }\r\n\r\n  prepareScene() {\r\n\r\n  \tthis.scene = new THREE.Scene();\r\n\t\tthis.renderer;\r\n\t\tthis.camera; \r\n\t\tthis.cameraControls;\r\n\t\tthis.controls;\r\n\t\t//this.projector;\r\n\r\n  \tif (this.utils.isWebGLSupported()) {\r\n\r\n\t\t\tthis.renderer = new THREE.WebGLRenderer({\r\n\t\t\t\tantialias: true\r\n\t\t\t});\r\n\r\n\t\t\tthis.renderer.setClearColor( 0x000000, 1 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tlet message = new Message({text: 'No WebGL', state: 'info'});\r\n\t\t\t\t\tmessage.render();\r\n\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\r\n\t\tthis.initCamera();\r\n\r\n\r\n\t\t// the position which the camera is currently looking at\r\n\t\tthis.cameraTarget = new THREE.Vector3(0,0,0);\r\n\r\n\t\t// this.cameraHelper = new CameraHelper({ app: self });\r\n\r\n\t\tthis.renderer.setSize( window.innerWidth, window.innerHeight );\r\n\t\tthis.renderer.shadowMap.enabled = true;\r\n\t\tthis.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\r\n\r\n\t\t/*\r\n\t\tthis.renderer.shadowCameraNear = 3;\r\n    this.renderer.shadowCameraFar = this.camera.far;\r\n    this.renderer.shadowCameraFov = 50;\r\n\r\n    this.renderer.shadowMapBias = 0.0039;\r\n    this.renderer.shadowMapDarkness = 0.5;\r\n    this.renderer.shadowMapWidth = 1024;\r\n    this.renderer.shadowMapHeight = 1024;\r\n\r\n    */\r\n\r\n\t\tthis.container = document.getElementById('scene');\r\n\t\tthis.container.appendChild(this.renderer.domElement);\r\n\r\n\t  // add event listeners\r\n\t  document.addEventListener( 'mousedown', (e) => this.onDocumentMouseMove(e), false );\r\n\t  document.addEventListener( 'mousemove', (e) => this.onDocumentMouseMove(e), false );\r\n\t  document.addEventListener( 'mouseover', (e) => this.onDocumentMouseMove(e), false );\r\n\r\n  }\r\n\r\n\r\n  init() {\r\n\r\n  \t// this.initCamera();\r\n\t\tthis.initLighting();\r\n\t\tthis.initResize();\r\n\r\n    if (this.options.renderStats)\r\n\t  \tthis.renderStats();\r\n\r\n\t  // this.loadLevel('level1');\r\n\t  // this.loadLevel('level2');\r\n\t  // this.loadLevel('level3');\r\n\t  // this.loadLevel('level3');\r\n\t  // this.loadLevel('level5');\r\n\r\n\t  this.loadLevel('christmas-tree-01');\r\n\t  // this.loadLevel('christmas-tree-06');\r\n\r\n\t  this.renderViews();\r\n\t  this.animate();\r\n\r\n  }\r\n\r\n\r\n\r\n  initCamera( target ) {\r\n\r\n  \tvar self = this;\r\n\r\n  \tif (target !== undefined || target != null)\r\n  \t\tself.cameraTarget = target;\r\n\r\n  \tvar width = $(window).width();\r\n  \tvar height = $(window).height();\r\n\r\n  \t// add the camera to the scene\r\n\t\tthis.camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, .1, 1000 );\r\n\t\t//this.camera = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 1, 1000 );\r\n\t\tthis.camera.updateProjectionMatrix();\r\n\r\n\t\t//this.cameraHelper = new THREE.CameraHelper(this.camera);\r\n\t\t//this.scene.add(this.cameraHelper);\r\n\r\n\t\tthis.utils.debug('current camera target', self.cameraTarget);\r\n\r\n\t\tif (this.options.view == '3d') {\r\n\r\n\t\t\tthis.cameraPos = { \r\n\t\t\t\tx: 0,\r\n\t\t\t\ty: 12, \r\n\t\t\t\tz: 8\r\n\t\t\t};\r\n\r\n\t\t\tconsole.log('rendering camera at:', this.cameraPos);\r\n\r\n\t\t\tthis.camera.position.set( this.cameraPos.x, this.cameraPos.y, this.cameraPos.z );\r\n\r\n\t\t}\r\n\t\t\r\n\t\tthis.scene.add(this.camera);\r\n\t\t// this.controls = new THREE.TrackballControls( this.camera, this.container );\r\n\r\n\t\tthis.controls = new THREE.OrbitControls( this.camera, this.container );\r\n\r\n\t\t//var vector = new THREE.Vector3( this.controls.target.x, this.controls.target.y, this.controls.target.z );\r\n  \t\t\t//vector.applyQuaternion( this.camera.quaternion );\r\n\r\n  \tthis.cameraTarget = this.controls.target;\r\n\r\n\t\tif (target !== undefined || target != null) {\r\n\t\t\t// window.utils.debug('defining new camera target', target);\r\n\r\n\t\t\t// define the camera position\r\n\t\t\tthis.cameraHelper.setCameraPosition(target);\t\r\n\r\n\t\t\t// define the target which the camera shoul look at\r\n\t\t\t//this.cameraHelper.setCameraTarget(target);\r\n\r\n\t\t} else {\r\n\t\t\tthis.camera.lookAt(this.cameraTarget);\r\n\t\t\t//this.cameraHelper.setCameraTarget( self.cameraTarget );\r\n\t\t}\r\n\r\n\r\n\t\tthis.cameraPosition = new THREE.Vector3();\r\n\t\tthis.cameraPosition = this.cameraPosition.setFromMatrixPosition( this.camera.matrixWorld );\r\n\t\tthis.cameraPositionOld = this.cameraPosition;\r\n\r\n\t  this.controls.rotateSpeed = .5;\r\n\t  this.controls.zoomSpeed = 1.8;\r\n\t  this.controls.panSpeed = .3;\r\n\r\n\r\n\t  // limit line\r\n\t  this.controls.maxPolarAngle = Math.PI/2;\r\n\r\n\t  //this.controls.minDistance = this.window.utils.makeDistance( 0.0001, 'au');\r\n\r\n\t  //this.controls.noZoom = false;\r\n\t  //this.controls.noPan = false;\r\n\r\n\t  this.controls.enableDamping = false;\r\n\t  this.controls.dampingFactor = 0.3;\r\n\r\n\t  this.controls.enableKeys = false;\r\n\t  this.controls.keys = [];\r\n\t  this.controls.addEventListener( 'change', this.render() );\r\n  }\r\n\r\n\r\n\tinitLighting() {\r\n\r\n\t  // add a very light ambient light\r\n\t  var globalLight = new THREE.AmbientLight(0xffffff);\r\n\r\n\t  globalLight.color.setRGB( \r\n\t  \t.521,\r\n\t  \t.521,\r\n\t  \t.521\r\n\t  );\r\n\r\n\t  this.scene.add( globalLight );\r\n\r\n\r\n\t  //directional light\r\n\t\tthis.directionalLight = new THREE.DirectionalLight(0xffffff, 1.75);\r\n\t\tthis.directionalLight.position.set(-6, 6, 11);\r\n\t\tthis.directionalLight.target.position.set(1, 1, 0);\r\n\t\t \r\n\t\tthis.directionalLight.castShadow = true;\r\n\t\t// this.directionalLight.shadowCameraVisible = true;\r\n\t\t//this.directionalLight.shadowDarkness = 0.5;\r\n\r\n\t\t//this.directionalLight.shadow.mapSize.width = 512 * 2;\r\n    //this.directionalLight.shadow.mapSize.height = 512 * 2;\r\n\t\t \r\n\t\tthis.directionalLight.shadow.camera.near = 0;\r\n\t\tthis.directionalLight.shadow.camera.far = 1000;\r\n\t\t \r\n\t\tthis.directionalLight.shadow.camera.left = -20;\r\n\t\tthis.directionalLight.shadow.camera.right = 20;\r\n\t\tthis.directionalLight.shadow.camera.top = 20;\r\n\t\tthis.directionalLight.shadow.camera.bottom = -20;\r\n \r\n\t\tthis.scene.add(this.directionalLight);\r\n\r\n\t\t//var lightHelper3 = new THREE.DirectionalLightHelper( this.directionalLight );\r\n\t\t//this.scene.add( lightHelper3 );\r\n  }\r\n\r\n\r\n  loadLevel (level) {\r\n\t\tvar self = this;\r\n\r\n\t\t$.ajax({\r\n\t\t  url: './src/json/'+ level +'.json?time=' + Math.random(),\r\n\t\t  dataType: 'json',\r\n\t\t  success: (level) => {\r\n\r\n\t\t  \tconsole.log(level);\r\n\t\t  \t\r\n\t\t  \tthis.level = new Level({\r\n\t\t  \t\tapp: this, \r\n\t\t  \t\tlevel: level\r\n\t\t  \t});\r\n\r\n\t\t  \tthis.level.render();\r\n\r\n\t\t  }\r\n\t\t});\r\n\r\n\t}\r\n\r\n\r\n\trenderViews() {\r\n\r\n\t\tthis.$interface = new Interface({app: this});\r\n\t\tthis.$interface.render();\r\n\r\n\t\tthis.$liftUpButton = new Button({\r\n\t\t\tapp: this,\r\n\t\t\tname: 'LiftUp',\r\n\t\t\ttext: 'Lift Up',\r\n\t\t\tobject: 'lift',\r\n\t\t\taction: 'moveUp'\r\n\t\t});\r\n\r\n\t\tthis.$liftDownButton = new Button({\r\n\t\t\tapp: this,\r\n\t\t\tname: 'LiftDown',\r\n\t\t\ttext: 'Lift Down',\r\n\t\t\tobject: 'lift',\r\n\t\t\taction: 'moveDown'\r\n\t\t});\r\n\r\n\t\tthis.$liftUpButton.render( $('#buttons') );\r\n\t\tthis.$liftDownButton.render( $('#buttons') );\r\n\r\n\t}\r\n\r\n\r\n  renderStats ( container = $('body') ) {\r\n  \tthis.stats = new Stats();\r\n\r\n  \t$(this.stats.domElement).attr('class', 'stats');\r\n  \t$(this.stats.domElement).css({\r\n\t\t\t'position': 'absolute',\r\n\t\t\t'bottom': '0',\r\n\t\t\t'z-index': 99\r\n\t\t});\r\n\r\n\t\tcontainer.append( this.stats.domElement );\r\n  }\r\n\r\n\r\n\r\n  initResize() {\r\n\r\n\t\twindow.addEventListener('resize', () => {\r\n\r\n      let w = window.innerWidth;\r\n      let h = window.innerHeight;\r\n\r\n      this.renderer.setSize( w, h );\r\n      this.camera.aspect = w / h;\r\n      this.camera.updateProjectionMatrix();\r\n    });\r\n\r\n  }\r\n\r\n\r\n\tanimate ( step ){\r\n  \tthis.timeElapsed = step;\r\n\r\n    // loop on request animation loop\r\n\t\t// - it has to be at the begining of the function\r\n\t\t// - see details at http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\r\n\t\trequestAnimationFrame( this.animate.bind( this ) );\r\n\t\tthis.controls.update();\r\n\r\n\r\n\t  // set the time\r\n\t  this.lastTime = this.time;\r\n\t  this.time = Date.now();\r\n\t  this.dt = this.time - this.lastTime;\r\n\t  this.simTime += this.dt * this.currentSpeed;\r\n\t  this.date = new Date(this.simTime);\r\n\t  this.simTimeSecs = this.simTime;\r\n\r\n\t\t// do the render\r\n\t\tthis.render(step);\r\n\r\n\t\t// update stats\r\n\t\tif (this.options.renderStats)\r\n\t\t\tthis.stats.update();\r\n  }\r\n\r\n\r\n  render (step) {\r\n\t\tvar self = this;\r\n\r\n\t\tthis.delta = this.clock.getDelta();\r\n\t\tthis.timeElapsed = this.clock.getElapsedTime();\r\n\r\n\t\t// this.renderCount++;\r\n\t\tvar now = _.now();\r\n\t\tvar currentDate = new Date(now - this.startTime);\r\n\t\tvar secondsElapsed = currentDate.getSeconds();\r\n\t\tvar minutesElapsed = currentDate.getMinutes();\r\n\t\t// window.utils.debug('time since app start', minutesElapsed + 'm ' + secondsElapsed + 's');\r\n\r\n\t\tif (this.$interface)\r\n\t\t\tthis.$interface.updateTime(this.timeElapsed);\r\n\r\n\t\tthis.currentRenderLoops++;\r\n\r\n\t\t// calculate current distance from solar center\r\n\t\tthis.cameraPosition = new THREE.Vector3();\r\n\t\tthis.cameraPosition = this.cameraPosition.setFromMatrixPosition( this.camera.matrixWorld );\r\n\r\n\t\t// distance in px\r\n\t\tthis.distanceCamera = this.cameraPosition.distanceTo( self.cameraTarget );\r\n\r\n\t\t// check if camera position changed and recalculate star sizes\r\n\t\tif (this.cameraPosition.y != this.cameraPositionOld.y) {\r\n\t\t\tthis.cameraPositionOld = this.cameraPosition;\r\n\t\t\tthis.timeElapsedSinceCameraMove = now;\r\n\t\t}\r\n\r\n\t\t// Move the camera in a circle with the pivot point in the center of this circle...\r\n\t  // ...so that the pivot point, and focus of the camera is on the center of the scene.\r\n\t  if ((now - this.timeElapsedSinceCameraMove) > 30000) {\r\n\t\t\t// this.cameraHelper.autoRotation();\r\n\t  }\r\n\r\n\t  if (this.level)\r\n\t  \tthis.level.animate(this.clock);\r\n\r\n\r\n\t  // this.cameraHelper.update();\r\n\r\n\t\t// TWEEN.update();\r\n\t\tthis.renderer.render( this.scene, this.camera );\r\n\t}\r\n\r\n\r\n\tupdateCamera (lookAt) {\r\n\r\n    let newPosY = this.cameraPos.y + lookAt;\r\n\r\n    this.camera.position.set( this.cameraPos.x, newPosY, this.cameraPos.z );\r\n    this.controls.target.set(0, lookAt, 0);\r\n\r\n\t}\r\n\r\n\r\n  onDocumentMouseMove(e) {\r\n\r\n\t\te.preventDefault();\r\n\r\n\t\tthis.updateMousePosition(e);\r\n\r\n\t\t//var self = this;\r\n\t\t//var vector = new THREE.Vector3( ( e.clientX / window.innerWidth ) * 2 - 1, - ( e.clientY / window.innerHeight ) * 2 + 1, .5 );\r\n\t\t// this.projector.unprojectVector( vector, this.camera );\r\n\r\n\t\t//vector.unproject(this.camera);\r\n\r\n\t\t//var rayCaster = new THREE.Raycaster( this.camera.position, vector.sub( this.camera.position ).normalize() );\r\n\t\r\n\r\n\t\t/*\r\n\t\t_.each( self.markers, function( marker, idx ){\r\n\t\t\tself.scene.remove( marker );\r\n\t\t});\r\n\t\t*/\r\n\r\n\t\t\r\n\t\t// var intersects = rayCaster.intersectObjects( this.meshes, true );\r\n\r\n\r\n\t\t//  check intersection of stars\r\n\t\t// this.intersectStars(e);\r\n\r\n\t\t// var mouse = { x: 0, y: 0, z: 1 };\r\n\r\n\t\t\r\n\r\n\t\t// this where begin to transform the mouse cordinates to three.js cordinates\r\n\t  // mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;\r\n\t  // mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;\r\n\t    \r\n\t  // this vector caries the mouse click cordinates\r\n\t  //var mouse_vector = new THREE.Vector3(0,0,0);\r\n\t  \t\t//mouse_vector.set( mouse.x, mouse.y, mouse.z );\r\n\r\n\t \t// this.projector.unprojectVector( mouse_vector, this.camera );\r\n\t  \r\n\t  //mouse_vector.unproject(this.camera);\r\n\r\n\t  //var direction = mouse_vector.sub( this.camera.position ).normalize();\r\n\t  //rayCaster.set( this.camera.position, direction );\r\n\t    \r\n\r\n\r\n\t\t// check if the user moves the mouse over a planet or host star\r\n\t\t/*\r\n\t\t_.each( this.meshes, function( mesh, idx ){\r\n\t\t\t//window.utils.debug(mesh);\r\n\t\t\tif( mesh.position ) {\r\n\t\t\t\tintersects = rayCaster.intersectObject( [mesh] );\r\n\r\n\t\t\t\tif( intersects.length > 0 ) {\r\n\t  \t\t\twindow.utils.debug( intersects[ 0 ].object );\r\n\t  \t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\t*/\r\n\r\n\t\t// s$('#tooltip').hide();\r\n\t\t// self.canvasElement.hideViewHelper();\r\n\t\t// this.checkStarMouseCollision(e);\r\n\r\n\t}\r\n\r\n\r\n\tupdateMousePosition ( e ) {\r\n\r\n\t\tthis.mouse.x = ( e.clientX / window.innerWidth ) * 2 - 1;\r\n\t\tthis.mouse.y = - ( e.clientY / window.innerHeight ) * 2 + 1;\r\n\r\n\t}\r\n\r\n}\r\n\r\n"],"sourceRoot":"/source/"}